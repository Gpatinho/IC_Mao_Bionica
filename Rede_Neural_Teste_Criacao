import numpy as np 
from tensorflow.keras.models import sequential # biblioteca, é um modelo de rede neural simples em que as camadas estão em sequência (uma após a outra).
form tensorflow.keras.layers import Dense # biblioteca, é uma camada totalmente conectada (cada entrada conecta a cada neurônio da próxima camada).
# nem todas as redes neurais usam "tensorflow.keras" pode usar outros tipos de modelos de contrução de redes neurais.

# Exemplos de temperaturas com a variavel "Exemplos_Temperatura" 

Exemplos_Temperatura = np.array ([ 

[15];       # muito frio
[18],
[22],
[25],       # temperadura ideal
[26],
[33],       # muito quente 
[35],
[36]

])

# comando para ligar e desligar os leds cada comando significa qual led vai ficar lgado ou qual led vai ficar deligado em cada estado que estiver a temperatura 
Exemplos_Comandos = np.array([

    [1, 1, 0, 0, 0],  # azul + amarelo (muito frio)
    [1, 1, 0, 0, 0],
    [0, 0, 1, 0, 0],  # verde (ideal)
    [0, 0, 1, 0, 0],
    [0, 0, 0, 1, 1],  # vermelho + branco (muito quente)
    [0, 0, 0, 1, 1]

])

model = sequential(), # criando uma rede simples e em sequencia sem ramificações 
model.add(Dense(8, input_dim=1 ativa = 'relu' )) # usamos 8 neuronios pois não é um problema dificl de ser solucionado então usamos poucos neuronios, input =1 pq temos apenas uma saida e "ativa= relu" é o que usamos para ativar o neuronio se ele for util na camada oculta 
model.add(Dense(5, ativa = 'sigmoid' )) # "ativa = sigmoid" é o que usamos para tranformar os dados de sainda em zero e um para utilizar com os led que serão saidas de liga e desliga

model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy']) # "compile" define como a rede sera avaliada e ajustada
model.fit(X, y, epochs=500, verbose=0)# "verbose" não imprime nada no terminal, "epochs" repete  treinamento 500 vezes, "fit" treina a rede com os dados 

testes = np.array([[15], [22], [36]])
pred = model.predict(testes)  # "predict" faz a rede gerar saidas com bases nas entradas

for t, p in zip(testes, pred): 
    print(f"Temp: {t[0]}°C → LEDs: {[round(i) for i in p]}") # "round" converte para zero ou um para simular os ledes liga e desliga

------------------------------------------------------------------------------------------------------------------------------------------------------------
import serial
import numpy as np
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

# === Etapa de Treinamento ===
# X: Temperatura em graus Celsius (simulados para treinar)
X = np.array([[15], [20], [25], [28], [32], [35], [38], [40]], dtype=float)
# y: Classe da temperatura
# 0 = frio, 1 = ideal, 2 = quente
y = np.array([0, 0, 1, 1, 2, 2, 2, 2], dtype=int)

# One-hot encoding da saída
from tensorflow.keras.utils import to_categorical
y_cat = to_categorical(y, num_classes=3)

# Criar modelo
model = Sequential()
model.add(Dense(8, input_dim=1, activation='relu'))
model.add(Dense(3, activation='softmax'))

model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
model.fit(X, y_cat, epochs=500, verbose=0)

# === Comunicação Serial com ESP32 ===
ser = serial.Serial('COM3', 115200)  # Troque COM3 pela sua porta
print("Conectado ao ESP32!")

def decidir_led(pred):
    classe = np.argmax(pred)
    if classe == 0:  # Muito frio
        return "LED=azul_amarelo"
    elif classe == 1:  # Ideal
        return "LED=verde"
    elif classe == 2:  # Muito quente
        return "LED=vermelho_branco"

while True:
    try:
        linha = ser.readline().decode().strip()
        temperatura = float(linha)
        entrada = np.array([[temperatura]])
        pred = model.predict(entrada, verbose=0)
        comando = decidir_led(pred)
        print(f"Temp: {temperatura:.2f}°C → {comando}")
        ser.write((comando + "\n").encode())
    except Exception as e:
        print("Erro:", e)







